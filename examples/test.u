let Sigma : (A:Type) -> (A -> Type) -> Type 
          = \A:Type. \P:A->Type. (R:Type) -> (U:(a:A) -> (b:P a) -> R) -> R
  ; pair  : (A:Type) -> (P:A->Type) -> (x:A) -> P x -> Sigma A P
          = \A:Type. \P:A->Type. \x:A. \y:P x. \R:Type. \cc:(a:A) -> (b:P a) -> R. cc x y

  ; Nat : Type = Sigma 2 (\tag:2. !case tag => \tag:2. $Type of { [1] ; [Nat] })
  ; tagf : 2 -> Type = \tag:2. !case tag => \tag:2. $Type of { [1] ; [Nat] }
  ; zero : Nat = pair 2 tagf (0:2) (0:1)
  ; succ : Nat -> Nat = \n:Nat. pair 2 tagf (1:2) n

  ; not : 2 -> 2 = \x:2. case x => \x:2. 2 of { (1:2) ; (0:2) }
  ; iterate : (A:Type) -> Nat -> (f:A->A) -> A -> A
            = \A:Type. \n:Nat. \f:A->A. \x0:A.
                 let go:Nat -> A = \n:Nat.
                       n A (\tag:2. !case tag => \tag:2. $(tagf tag -> A) of 
                                     { [\n:1. x0] ; [\n:Nat. f (go n)] })
                 in go n
  ; even : Nat -> 2 = \n:Nat. iterate 2 n not (1:2)
  ; id : Nat -> Nat = \n:Nat. n Nat (\tag:2. !case tag => \tag:2. $(tagf tag -> Nat) of { [\n:1. zero] ; [\n:Nat. succ n] })
in iterate 2 (succ (succ (succ zero)))
